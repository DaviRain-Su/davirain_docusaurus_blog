# 基材生锈
使 Substrate 成为创建任务关键型软件的灵活且可扩展的框架的大部分原因都归功于Rust。作为 Substrate 的首选语言，Rust 是一种高性能的编程语言，并且是首选语言，原因如下：

Rust 速度很快：它在编译时是静态类型的，这使得编译器可以优化代码以提高速度，并让开发人员可以针对特定的编译目标进行优化。
Rust 是可移植的：它被设计为在支持任何类型操作系统的嵌入式设备上运行。
Rust 是内存安全的：它没有垃圾收集器，它检查你使用的每一个变量和你引用的每一个内存地址，以避免任何内存泄漏。
Rust 首先是 Wasm：它对编译到 WebAssembly 有一流的支持。
基材生锈
在架构部分，您将了解到 Substrate 由两个不同的架构组件组成：外部节点和运行时。虽然在外部节点代码中使用了 Rust 中更复杂的功能，例如多线程和异步 Rust，但它们并不直接暴露给运行时工程师，使运行时工程师更容易专注于其节点的业务逻辑。

通常，根据他们的重点，开发人员应该期望知道：

基本的Rust 习语，使用no_std宏以及使用什么宏以及为什么（用于运行时工程）。
异步 Rust（适用于使用外部节点（客户端）代码的更高级的开发人员）。
尽管在深入了解 Substrate 之前对 Rust 的一般熟悉是必不可少的——并且有许多资源可用于学习 Rust，包括Rust 语言编程书和Rust 示例——本节的其余部分将重点介绍 Substrate 使用 Rust 的一些核心特性的方式，以便开发人员获得从运行时工程开始。

编译目标
在构建 Substrate 节点时，我们使用wasm32-unknown-unknown编译目标，这意味着 Substrate 运行时工程师受限于编写必须编译为 Wasm 的运行时。这意味着您不能依赖一些典型的标准库类型和函数，而只能no_std对大多数运行时代码使用兼容的 crate。Substrate 有许多自己的原始类型和相关特征，可以解决no_std需求。

宏
当您学习编写 FRAME 托盘时，您将很快遇到各种不同类型的宏，这些宏旨在抽象和执行任何运行时特定要求。有了它们，您可以专注于编写惯用的 Rust，最大限度地减少编写额外代码的开销，否则您需要编写与运行时正确交互的代码。

Rust 宏是一种强大的工具，可帮助确保满足某些要求（无需重写代码），例如以特定方式格式化的逻辑、进行特定检查或某些逻辑由特定数据结构组成。这对于帮助开发人员编写可以与 Substrate 运行时的复杂性集成的代码特别有用。例如，#[frame_system::pallet]所有 FRAME 托盘都需要该宏，以帮助您正确实现某些必需的属性（例如存储项目或外部可调用函​​数），并使其与construct_runtime.

开发 Substrate 运行时涉及大量使用 Rust 的属性宏，它有两种风格：派生属性和自定义属性。当您开始使用 Substrate 时，确切地知道它们是如何工作的并不是那么重要，而是知道它们的存在以使您能够编写正确的运行时代码。

派生属性对于需要满足某些特征的自定义运行时类型很有用，例如，在运行时执行期间使类型可由节点解码。

其他属性（如宏）在 Substrate 的代码库中也很常见，用于：

告诉编译器代码片段是否要编译到no_std或可以访问std库。
自定义 FRAME 支持用于编写托盘的宏。
指定构建运行时的方式。
泛型和配置特征
通常与 Java 等语言中的接口相比，Rust 中的特征提供了为类型提供高级功能的方法。

如果您阅读过有关托盘的内容，您可能已经注意到每个托盘都有一个Config特征，它允许您定义托盘所依赖的类型和接口。

此 trait 本身从 trait 继承了许多核心运行时类型frame_system::pallet::Config，使得在编写运行时逻辑时可以轻松访问常用类型。此外，在任何 FRAME 托盘中，Config特征都是泛型的T（下一节将详细介绍泛型）。这些核心运行时类型的一些常见示例可能是运行时T::AccountId中识别用户帐户的常见类型或运行时T::BlockNumber使用的块号类型。

有关 Rust 中泛型类型和特征的更多信息，请参阅Rust 书中有关泛型类型、特征和高级特征的部分。

使用 Rust 泛型，Substrate 运行时开发人员可以编写完全不了解特定实现细节的托盘，从而充分利用 Substrate 的灵活性、可扩展性和模块化。

trait 中的所有类型Config通常使用 trait bound 定义，并在运行时实现中具体化。这不仅意味着您可以编写支持同一类型的不同规格的托盘（例如，Substrate 和以太坊链的地址），而且您还可以根据您的需要以最小的开销自定义通用实现（例如，将块号更改为u32）。

这使开发人员可以灵活地编写代码，而无需对您所做的核心区块链架构决策做出任何假设。

Substrate 最大限度地使用泛型类型以提供最大的灵活性。您定义如何解析泛型类型以适合您的目的。

有关 Rust 中泛型类型和特征的更多信息，请参阅Rust 书中有关泛型类型的部分。

下一步去哪里
既然您知道 Substrate 如何依赖于几个关键的 Rust 特性（如特征、泛型类型和宏），您可以探索以下资源以了解更多信息。

锈书
为什么要生锈？（平价博客）
货物和板条箱.io
为什么要为智能合约使用 Rust？（墨水！文档）